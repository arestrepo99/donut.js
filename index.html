
<canvas id="canvas">

</canvas>

<script>

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Screeen size
const screenWidth = window.innerWidth;
const screenHeight = window.innerHeight;

// Set canvas width and height as screenWidth
canvas.width = screenWidth-20;
canvas.height = screenWidth-20;


const width = 800; const height = 800;

class Screen{

    constructor(width, height){
        this.width = width;
        this.height = height;
        this.data = new Uint8ClampedArray(width * height * 4);
        for (let i = 0; i< this.data.length; i+=4) {
            // this.data[i + 0] = i/100; // R value
            // this.data[i + 1] = height+i/100; // G value
            // this.data[i + 2] = 0; // B value
            this.data[i + 3] = 255; // A value
        }
        this.light = new Vector(0.5,0.5,-1).normalize();
        // this.light = new Vector(0,0,-1).normalize();
        this.camera = {
            direction: new Vector(0,0,1),
        }
    }

    set(x,y, value){
        x = Math.floor(x) + this.width/2; y = Math.floor(y) + this.height/2;
        this.data[(y*this.width + x)*4 + 0] = value[0];
        this.data[(y*this.width + x)*4 + 1] = value[1];
        this.data[(y*this.width + x)*4 + 2] = value[2];
        this.data[(y*this.width + x)*4 + 3] = 255;
    }

    get(x,y) {
        x = Math.floor(x) + this.width/2; y = Math.floor(y) + this.height/2;
        return [
            this.data[(y*this.width + x)*4 + 0],
            this.data[(y*this.width + x)*4 + 1],
            this.data[(y*this.width + x)*4 + 2],
            this.data[(y*this.width + x)*4 + 3],
        ]
    }

    point(point, value){
        this.set(point.x, point.y, value);
    }


    line(point1, point2, value1, value2) {
        // Line rasterization
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        const xinc = dx / steps;
        const yinc = dy / steps;
        let x = point1.x;
        let y = point1.y;
        let value = value1;
        for (let i = 0; i < steps; i++) {
            this.set(Math.floor(x), Math.floor(y), value);
            x += xinc;
            y += yinc;
            value = value.map((v, i) => v + (value2[i] - value1[i]) / steps);
        }
    }


    triangle(triangle, color){
        // const {c1,c2,c3} = color;

        // Triangle rasterization
        const normal = triangle.normal();
        // Check if triangle is backfacing
        if ( normal.dot(this.camera.direction) > 0) return;
        // console.log(normal)
        const intensity = Math.max(0,normal.dot(this.light)) * 255;
        // console.log(intensity);

        // // Draw lines
        const p1 = triangle.p1;
        const p2 = triangle.p2;
        const p3 = triangle.p3;

        const minx = Math.floor(Math.min(p1.x, p2.x, p3.x));
        const miny = Math.floor(Math.min(p1.y, p2.y, p3.y));

        const maxx = Math.ceil(Math.max(p1.x, p2.x, p3.x));
        const maxy = Math.ceil(Math.max(p1.y, p2.y, p3.y));

        for ( let x = minx; x < maxx; x++){
            for (let y = miny; y < maxy; y++){
                const {w, v, u} = triangle.barycentric(x,y);
                if ( w >= -0.01 && v >= -0.01 && u >= -0.01 && w <= 1.01 && v <= 1.01 && u <= 1.01){
                    this.set(x,y, [intensity, intensity, intensity]);
                }
            }
        }

    }


    draw(upsample = 1){
        let array = this.data;
        if (upsample > 1){
            // Upsample
            array = new Uint8ClampedArray(this.width * this.height * 4 * upsample * upsample);
            for (let i = 0; i < this.width; i++){
                for (let j = 0; j < this.height; j++){
                    for (let x = 0; x < upsample; x++){
                        for (let y = 0; y < upsample; y++){
                            array[((j*upsample+y)*this.width*upsample + (i*upsample+x))*4 + 3] = 255;
                            array[((j*upsample+y)*this.width*upsample + (i*upsample+x))*4 + 0] = this.data[(j*this.width + i)*4 + 0];
                            array[((j*upsample+y)*this.width*upsample + (i*upsample+x))*4 + 1] = this.data[(j*this.width + i)*4 + 1];
                            array[((j*upsample+y)*this.width*upsample + (i*upsample+x))*4 + 2] = this.data[(j*this.width + i)*4 + 2];
                        }
                    }
                }
            }
        }
        
        const imageData = new ImageData(array, this.width*upsample, this.height*upsample);
        ctx.putImageData(imageData, 0,0)
    }

}

class Vector{
    constructor(x,y,z){
        this.x = x;
        this.y = y;
        this.z = z;
    }

    normalize(){
        const length = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
        return new Vector(this.x/length, this.y/length, this.z/length);
    }

    rotateX(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const y = this.y * cosa - this.z * sina;
        const z = this.y * sina + this.z * cosa;
        return new Vector(this.x, y, z);
    }

    rotateY(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const x = this.x * cosa - this.z * sina;
        const z = this.x * sina + this.z * cosa;
        return new Vector(x, this.y, z);
    }

    rotateZ(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const x = this.x * cosa - this.y * sina;
        const y = this.x * sina + this.y * cosa;
        return new Vector(x, y, this.z);
    }

    rotate(rads) {
        let p = this.rotateX(rads.x);
        p = p.rotateY(rads.y);
        p = p.rotateZ(rads.z);
        return p;
    }

    dot(point){
        return this.x * point.x + this.y * point.y + this.z * point.z;
    }

    copy() {
        return new Vector(this.x, this.y, this.z);
    }

    // Substracts a vector from this vector
    sub(point){
        return new Vector(this.x - point.x, this.y - point.y, this.z - point.z);
    }
    // Adds a vector to this vector
    add(point){
        return new Vector(this.x + point.x, this.y + point.y, this.z + point.z);
    }

    cross(point) {
        return new Vector(
            this.y * point.z - this.z * point.y,
            this.z * point.x - this.x * point.z,
            this.x * point.y - this.y * point.x,
        );
    }

}

Vector.prototype['-'] = function(point){return this.sub(point);}
Vector.prototype['+'] = function(point){return this.add(point);}


class Triangle{

    constructor(p1, p2, p3){
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }

    normal(){
        const v1 = this.p2.sub(this.p1);
        const v2 = this.p3.sub(this.p1);
        return v1.cross(v2).normalize();
    }


    // Get the w1 and w2 values for a point
    barycentric(x,y) {
        const p1 = this.p1.copy(); p1.z = 0;
        const p2 = this.p2.copy(); p2.z = 0;
        const p3 = this.p3.copy(); p3.z = 0;

        const v0 = p1.sub(p2);
        const v1 = p1.sub(p3);
        const v2 = new Vector(p1.x - x, p1.y - y, 0);
        const d00 = v0.dot(v0);
        const d01 = v0.dot(v1);
        const d11 = v1.dot(v1);
        const d20 = v2.dot(v0);
        const d21 = v2.dot(v1);
        const denom = d00 * d11 - d01 * d01;
        const w = (d11 * d20 - d01 * d21) / denom;
        const v = (d00 * d21 - d01 * d20) / denom;
        const u = 1 - w - v;
        return {w, v, u};
    }

}


const CIRCLE_RADIUS = 80;
const HOLE_RADIUS = 90;
const N_STEPS_CIRCLE = 100;
const N_STEPS_DONUT = 100;

function drawDonut(rotation){
    const step_circle = 2*Math.PI/N_STEPS_CIRCLE;
    const step_donut = 2*Math.PI/N_STEPS_DONUT;
    const triangles = [];
    const points = [];
    const lines = [];
    
    for (let i = 0; i < 2*Math.PI; i+=step_circle){
        for (j = 0; j < 2*Math.PI; j+=step_donut){
            let p1 = new Vector(
                Math.cos(i)*CIRCLE_RADIUS + ( HOLE_RADIUS + CIRCLE_RADIUS),
                Math.sin(i)*CIRCLE_RADIUS,
                0,
            )
            let p2 = new Vector(
                Math.cos(i+step_circle)*CIRCLE_RADIUS + ( HOLE_RADIUS + CIRCLE_RADIUS),
                Math.sin(i+step_circle)*CIRCLE_RADIUS,
                0,
            )
            let p3 = p1.copy();
            let p4 = p2.copy();
            p1 = p1.rotateY(j);
            p2 = p2.rotateY(j);
            p3 = p3.rotateY(j+step_donut);
            p4 = p4.rotateY(j+step_donut);

            p1 = p1.rotate(rotation);
            p2 = p2.rotate(rotation);
            p3 = p3.rotate(rotation);
            p4 = p4.rotate(rotation);

            t1 = new Triangle(p1, p2, p3);
            t2 = new Triangle(p3, p2, p4);
            
            points.push(p1);
            lines.push([p1, p2]);
            lines.push([p1, p3]);
            triangles.push(t1);
            triangles.push(t2);
        }
    }

    const screen = new Screen(width, height);

    // Sort triangles by z position of first point
    
    triangles.sort((a,b) => {
        return  b.p1.z- a.p1.z ;
    });
    triangles.forEach(triangle => {
        screen.triangle(triangle);
    });
    // Draw lines
    lines.forEach(line => {
        // screen.line(line[0], line[1], [0, 0, 0], [0, 0, 0]);
    });
    // Draw points
    points.forEach(point => {
        // screen.point(point, [150, 0, 0]);
    });
    screen.draw();
}


function drawTriange(rotation){
    const size = 50;
    const screen = new Screen(size, size);
    const triangle_height = size / 3;
    p1 = new Vector(triangle_height, 0, 0);
    p2 = new Vector(-triangle_height, 0, 0);
    p3 = new Vector(0, -triangle_height, 0);

    p1 = p1.rotate(rotation);
    p2 = p2.rotate(rotation);
    p3 = p3.rotate(rotation);

    t = new Triangle(p2, p1, p3);

    screen.triangle(t);
    
    screen.line(p1, p2, [255, 0, 0], [255, 0, 0]);
    screen.line(p2, p3, [255, 0, 0], [255, 0, 0]);
    screen.line(p3, p1, [255, 0, 0], [255, 0, 0]);


    screen.point(p1, [255, 0, 0]);
    screen.point(p2, [255, 0, 0]);
    screen.point(p3, [255, 0, 0]);
    screen.draw(10);
}



// drawDonut(1,1,0);

const rotation = {
    x: 0,
    y: 0,//-Math.PI/4,
    z: 0,
}
// Animation

function loop(timestamp) {
    seconds = timestamp/1000;
    drawDonut(rotation);
    // drawTriange(rotation);
    rotation.x = Math.PI*seconds * 0.1;
    rotation.y = Math.PI*seconds * 0.2;

    // requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);
</script>