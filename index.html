
<canvas id="canvas">

</canvas>

<script>

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Screeen size
const screenWidth = window.innerWidth;
const screenHeight = window.innerHeight;

// Set canvas width and height as screenWidth
canvas.width = screenWidth-20;
canvas.height = screenWidth-20;


const width = 800; const height = 800;

class Screen{

    constructor(width, height){
        this.width = width;
        this.height = height;
        this.data = new Uint8ClampedArray(width * height * 4);
        for (let i = 0; i< this.data.length; i+=4) {
            // this.data[i + 0] = i/100; // R value
            // this.data[i + 1] = height+i/100; // G value
            // this.data[i + 2] = 0; // B value
            this.data[i + 3] = 255; // A value
        }
        this.light = new Vector(0.5,0.5,-1);
        this.camera = {
            direction: new Vector(0,0,1),
        }
    }

    set(x,y, value){
        x = Math.floor(x) + this.width/2; y = Math.floor(y) + this.height/2;
        this.data[(y*this.width + x)*4 + 0] = value[0];
        this.data[(y*this.width + x)*4 + 1] = value[1];
        this.data[(y*this.width + x)*4 + 2] = value[2];
        this.data[(y*this.width + x)*4 + 3] = 255;
    }

    point(point, value){
        this.set(point.x, point.y, value);
    }


    line(point1, point2, value1, value2) {
        // Line rasterization
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        const xinc = dx / steps;
        const yinc = dy / steps;
        let x = point1.x;
        let y = point1.y;
        let value = value1;
        for (let i = 0; i < steps; i++) {
            this.set(Math.floor(x), Math.floor(y), value);
            x += xinc;
            y += yinc;
            value = value.map((v, i) => v + (value2[i] - value1[i]) / steps);
        }
    }


    triangle(triangle, value){
        // Triangle rasterization
        const normal = triangle.normal();
        // Check if triangle is backfacing
        if ( normal.dot(this.camera.direction) > 0) return;
        const intensity = Math.max(0,normal.dot(this.light))


        // // Draw lines
        this.line(triangle.p1, triangle.p2, [intensity, intensity, intensity], [intensity, intensity, intensity]);
        this.line(triangle.p2, triangle.p3, [intensity, intensity, intensity], [intensity, intensity, intensity]);
        this.line(triangle.p3, triangle.p1, [intensity, intensity, intensity], [intensity, intensity, intensity]);

        // console.log(line1, line2, line3);
        // Scan lines
        // const p1 = triangle.p1;
        // const p2 = triangle.p2;
        // const p3 = triangle.p3;

        // const minx = Math.floor(Math.min(p1.x, p2.x, p3.x));
        // const miny = Math.floor(Math.min(p1.y, p2.y, p3.y));

        // const maxx = Math.ceil(Math.max(p1.x, p2.x, p3.x));
        // const maxy = Math.ceil(Math.max(p1.y, p2.y, p3.y));

        // for ( let x = minx; x < maxx; x++){
        //     for (let y = miny; y < maxy; y++){
        //         const b = triangle.barycentric(x,y)
        //         if (b.x > 0 && b.y > 0 && b.z > 0){
        //             this.set(x,y, [255,255,255]);
        //         }
        //     }
        // }

    }


    draw(){
        const imageData = new ImageData(this.data, this.width, this.height);
        ctx.putImageData(imageData, 0,0)
    }

}

class Vector{
    constructor(x,y,z){
        this.x = x;
        this.y = y;
        this.z = z;
    }

    rotateX(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const y = this.y * cosa - this.z * sina;
        const z = this.y * sina + this.z * cosa;
        return new Vector(this.x, y, z);
    }

    rotateY(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const x = this.x * cosa - this.z * sina;
        const z = this.x * sina + this.z * cosa;
        return new Vector(x, this.y, z);
    }

    rotateZ(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const x = this.x * cosa - this.y * sina;
        const y = this.x * sina + this.y * cosa;
        return new Vector(x, y, this.z);
    }

    rotate(rads) {
        let p = this.rotateX(rads.x);
        p = p.rotateY(rads.y);
        p = p.rotateZ(rads.z);
        return p;
    }

    dot(point){
        return this.x * point.x + this.y * point.y + this.z * point.z;
    }

    copy() {
        return new Vector(this.x, this.y, this.z);
    }

    // Substracts a vector from this vector
    sub(point){
        return new Vector(this.x - point.x, this.y - point.y, this.z - point.z);
    }
    // Adds a vector to this vector
    add(point){
        return new Vector(this.x + point.x, this.y + point.y, this.z + point.z);
    }

    cross(point) {
        return new Vector(
            this.y * point.z - this.z * point.y,
            this.z * point.x - this.x * point.z,
            this.x * point.y - this.y * point.x,
        );
    }

}

Vector.prototype['-'] = function(point){return this.sub(point);}
Vector.prototype['+'] = function(point){return this.add(point);}


class Triangle{

    constructor(p1, p2, p3){
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }

    normal(){
        const v1 = this.p2.sub(this.p1);
        const v2 = this.p3.sub(this.p1);
        return v1.cross(v2);
    }

    barycentric(x,y) {
        const v0 = this.p2.sub(this.p1);
        const v1 = this.p3.sub(this.p1);
        const v2 = new Vector(this.p1.x - x, this.p1.y - y, 0);
        const d00 = v0.dot(v0);
        const d01 = v0.dot(v1);
        const d11 = v1.dot(v1);

        const d20 = v2.dot(v0);
        const d21 = v2.dot(v1);
        const denom = d00 * d11 - d01 * d01;
        const v = (d11 * d20 - d01 * d21) / denom;
        const w = (d00 * d21 - d01 * d20) / denom;
        const u = 1.0 - v - w;
        return new Vector(u,v,w);
    }

}


const CIRCLE_RADIUS = 40*2;
const HOLE_RADIUS = 30*3;
const N_STEPS_CIRCLE = 50;
const N_STEPS_DONUT = 50;

function drawDonut(rotation){
    const screen = new Screen(width, height);
    const step_circle = 2*Math.PI/N_STEPS_CIRCLE;
    const step_donut = 2*Math.PI/N_STEPS_DONUT;
    for (let i = 0; i < 2*Math.PI; i+=step_circle){
        for (j = 0; j < 2*Math.PI; j+=step_donut){
            let p1 = new Vector(
                Math.cos(i)*CIRCLE_RADIUS + ( HOLE_RADIUS + CIRCLE_RADIUS),
                Math.sin(i)*CIRCLE_RADIUS,
                0,
            )
            let p2 = new Vector(
                Math.cos(i+step_circle)*CIRCLE_RADIUS + ( HOLE_RADIUS + CIRCLE_RADIUS),
                Math.sin(i+step_circle)*CIRCLE_RADIUS,
                0,
            )
            let p3 = p1.copy();
            let p4 = p2.copy();
            p1 = p1.rotateY(j);
            p2 = p2.rotateY(j);
            p3 = p3.rotateY(j+step_donut);
            p4 = p4.rotateY(j+step_donut);

            p1 = p1.rotate(rotation);
            p2 = p2.rotate(rotation);
            p3 = p3.rotate(rotation);
            p4 = p4.rotate(rotation);
            
            screen.point(p1, [150, 0, 0]);
            screen.point(p2, [150, 0, 0]);
            screen.point(p3, [150, 0, 0]);

            t1 = new Triangle(p1, p2, p3);
            t2 = new Triangle(p3, p2, p4);
            
            screen.triangle(t1, [255, 255, 255]);
            // screen.triangle(t2, [255, 255, 255]);
            // break
        }
        // break
    }
    screen.draw();
}


// drawDonut(1,1,0);

const rotation = {
    x: 0,
    y: -Math.PI/2,
    z: 0,
}
// Animation

function loop(timestamp) {
    seconds = timestamp/1000;
    drawDonut(rotation);
    rotation.x += 0.005;
    rotation.x = Math.PI*seconds * 0.1;
    rotation.y = Math.PI*seconds * 0.2;

    requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);
</script>