
<canvas id="canvas">

</canvas>

<!-- <script src="gpu-browser.min.js"></script> -->

<script>

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Screeen size
const screenWidth = window.innerWidth;
const screenHeight = window.innerHeight;

// Set canvas width and height as screenWidth
canvas.width = screenWidth-20;
canvas.height = screenWidth-20;


const width = 800; const height = 800;

class Screen{

    constructor(width, height){
        this.width = width;
        this.height = height;
        this.data = new Uint8ClampedArray(width * height * 4);
        for (let i = 0; i< this.data.length; i+=4) {
            // this.data[i + 0] = i/100; // R value
            // this.data[i + 1] = height+i/100; // G value
            // this.data[i + 2] = 0; // B value
            this.data[i + 3] = 255; // A value
        }
        this.light = new Vector(0.5,0.5,-1).normalize();
        // this.light = new Vector(0,0,-1).normalize();
        this.camera = {
            direction: new Vector(0,0,1),
        }
    }

    set(x,y, value){
        x = Math.floor(x) + this.width/2; y = Math.floor(y) + this.height/2;
        this.data[(y*this.width + x)*4 + 0] = value[0];
        this.data[(y*this.width + x)*4 + 1] = value[1];
        this.data[(y*this.width + x)*4 + 2] = value[2];
        this.data[(y*this.width + x)*4 + 3] = 255;
    }

    get(x,y) {
        x = Math.floor(x) + this.width/2; y = Math.floor(y) + this.height/2;
        return [
            this.data[(y*this.width + x)*4 + 0],
            this.data[(y*this.width + x)*4 + 1],
            this.data[(y*this.width + x)*4 + 2],
            this.data[(y*this.width + x)*4 + 3],
        ]
    }

    point(point, value){
        this.set(point.x, point.y, value);
    }


    line(line, value1, value2) {
        const point1 = line.p1;
        const point2 = line.p2;
        // Line rasterization
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        const xinc = dx / steps;
        const yinc = dy / steps;
        let x = point1.x;
        let y = point1.y;
        let value = value1;
        for (let i = 0; i < steps; i++) {
            this.set(Math.floor(x), Math.floor(y), value);
            x += xinc;
            y += yinc;
            value = value.map((v, i) => v + (value2[i] - value1[i]) / steps);
        }
    }


    triangle(triangle){
        // Triangle rasterization
        const {n1, n2, n3} = triangle.getNormalAtVertices();
        // Check if triangle is backfacing
        if ( triangle.normal().dot(this.camera.direction) > 0) return;

        const intensity = {
            i1: Math.max(0, n1.dot(this.light)),
            i2: Math.max(0, n2.dot(this.light)),
            i3: Math.max(0, n3.dot(this.light)),
        }
        const p1 = triangle.p1;
        const p2 = triangle.p2;
        const p3 = triangle.p3;

        const minx = Math.floor(Math.min(p1.x, p2.x, p3.x));
        const miny = Math.floor(Math.min(p1.y, p2.y, p3.y));

        const maxx = Math.ceil(Math.max(p1.x, p2.x, p3.x));
        const maxy = Math.ceil(Math.max(p1.y, p2.y, p3.y));

        for ( let x = minx; x < maxx; x++){
            for (let y = miny; y < maxy; y++){
                const {u, w, v} = triangle.barycentric(x,y);
                if ( w >= -0.01 && v >= -0.01 && u >= -0.01 && w <= 1.01 && v <= 1.01 && u <= 1.01){
                    const mixed_intensity = (intensity.i1 * u + intensity.i2 * w + intensity.i3 * v) * 255;
                    this.set(x,y, [mixed_intensity, mixed_intensity, mixed_intensity]);
                }
            }
        }
    }

    upsample(number) {
        const array = this.data;
        // Upsample
        array = new Uint8ClampedArray(this.width * this.height * 4 * number * number);
        for (let i = 0; i < this.width; i++){
            for (let j = 0; j < this.height; j++){
                for (let x = 0; x < number; x++){
                    for (let y = 0; y < number; y++){
                        array[((j*number+y)*this.width*number + (i*number+x))*4 + 3] = 255;
                        array[((j*number+y)*this.width*number + (i*number+x))*4 + 0] = this.data[(j*this.width + i)*4 + 0];
                        array[((j*number+y)*this.width*number + (i*number+x))*4 + 1] = this.data[(j*this.width + i)*4 + 1];
                        array[((j*number+y)*this.width*number + (i*number+x))*4 + 2] = this.data[(j*this.width + i)*4 + 2];
                    }
                }
            }
        }
        return array;
    }


    blur(kernelSize) {
        const gpu = new GPU();
        for (let i = 0; i < this.width; i++){
            for (let j = 0; j < this.height; j++){
                let r = 0, g = 0, b = 0;
                for (let x = 0; x < kernelSize; x++){
                    for (let y = 0; y < kernelSize; y++){
                        const k = kernel[x*kernelSize + y];
                        r += this.data[((j+y)*this.width + (i+x))*4 + 0] * k;
                        g += this.data[((j+y)*this.width + (i+x))*4 + 1] * k;
                        b += this.data[((j+y)*this.width + (i+x))*4 + 2] * k;
                    }
                }
                array[(j*this.width + i)*4 + 0] = r;
                array[(j*this.width + i)*4 + 1] = g;
                array[(j*this.width + i)*4 + 2] = b;
            }
        }
        return array;
    }

    draw(upsample = 1){
        let array = this.data;
        if (upsample > 1) array = this.upsample(upsample);
        // array = this.blur(4);
        const imageData = new ImageData(array, this.width*upsample, this.height*upsample);
        ctx.putImageData(imageData, 0,0)
    }

}

class Vector{
    constructor(x,y,z){
        this.x = x;
        this.y = y;
        this.z = z;
    }

    normalize(){
        const length = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
        return new Vector(this.x/length, this.y/length, this.z/length);
    }

    rotateX(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const y = this.y * cosa - this.z * sina;
        const z = this.y * sina + this.z * cosa;
        return new Vector(this.x, y, z);
    }

    rotateY(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const x = this.x * cosa - this.z * sina;
        const z = this.x * sina + this.z * cosa;
        return new Vector(x, this.y, z);
    }

    rotateZ(rad){
        const cosa = Math.cos(rad);
        const sina = Math.sin(rad);
        const x = this.x * cosa - this.y * sina;
        const y = this.x * sina + this.y * cosa;
        return new Vector(x, y, this.z);
    }

    rotate(rads) {
        let p = this.rotateX(rads.x);
        p = p.rotateY(rads.y);
        p = p.rotateZ(rads.z);
        return p;
    }

    dot(point){
        return this.x * point.x + this.y * point.y + this.z * point.z;
    }

    copy() {
        return new Vector(this.x, this.y, this.z);
    }

    // Substracts a vector from this vector
    sub(point){
        return new Vector(this.x - point.x, this.y - point.y, this.z - point.z);
    }
    // Adds a vector to this vector
    add(point){
        return new Vector(this.x + point.x, this.y + point.y, this.z + point.z);
    }

    cross(point) {
        return new Vector(
            this.y * point.z - this.z * point.y,
            this.z * point.x - this.x * point.z,
            this.x * point.y - this.y * point.x,
        );
    }

    getZ(){
        return this.z;
    }

}


class Line {

    constructor (p1, p2){
        this.p1 = p1;
        this.p2 = p2;
    }

    rotate(rotation){
        return new Line(this.p1.rotate(rotation), this.p2.rotate(rotation));
    }

    getZ(){
        return (this.p1.z + this.p2.z)/2 - 20;
    }

}


class Triangle{

    constructor(p1, p2, p3, texture){
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
        this.texture = texture;
    }



    setNormalAtVertices(n1, n2, n3){
        this.n1 = n1; this.n2 = n2; this.n3 = n3;
    }

    getNormalAtVertices(){
        if (this.n1 && this.n2 && this.n3) return {n1: this.n1, n2: this.n2, n3: this.n3};
        const n = this.normal();
        return {n1: n, n2: n, n3: n};
    }

    normal(){
        const v1 = this.p2.sub(this.p1);
        const v2 = this.p3.sub(this.p1);
        return v1.cross(v2).normalize();
    }

    // Get the w1 and w2 values for a point
    barycentric(x,y) {
        const p1 = this.p1.copy(); p1.z = 0;
        const p2 = this.p2.copy(); p2.z = 0;
        const p3 = this.p3.copy(); p3.z = 0;

        const v0 = p1.sub(p2);
        const v1 = p1.sub(p3);
        const v2 = new Vector(p1.x - x, p1.y - y, 0);
        const d00 = v0.dot(v0);
        const d01 = v0.dot(v1);
        const d11 = v1.dot(v1);
        const d20 = v2.dot(v0);
        const d21 = v2.dot(v1);
        const denom = d00 * d11 - d01 * d01;
        const w = (d11 * d20 - d01 * d21) / denom;
        const v = (d00 * d21 - d01 * d20) / denom;
        const u = 1 - w - v;
        return {u, w, v}; 
        // u corresponds to p1, v to p2 and w to p3
    }

    texture(x,y, width, height){
        if (!texture) return [255, 255, 255, 255];
        barycentric = this.barycentric(x,y);
        return texture.getPixel(x/width, y/height);
    }

    rotate(rotation){
        const p1 = this.p1.rotate(rotation);
        const p2 = this.p2.rotate(rotation);
        const p3 = this.p3.rotate(rotation);
        const triangle = new Triangle(p1, p2, p3);
        // Rotate normals
        if (this.n1 && this.n2 && this.n3) {
            const n1 = this.n1.rotate(rotation);
            const n2 = this.n2.rotate(rotation);
            const n3 = this.n3.rotate(rotation);
            triangle.setNormalAtVertices(n1, n2, n3);
        }
        return triangle;
    }

    getZ(){
        return (this.p1.z + this.p2.z + this.p3.z)/3;
    }

}


const CIRCLE_RADIUS = 80;
const HOLE_RADIUS = 90;
const N_STEPS_CIRCLE = 50;
const N_STEPS_DONUT = 50;


class Texture{

    constructor(array, width, height){
        this.arrray = array;
    }

    getPixel(verticalRatio, horizontalRatio){
        const x = Math.floor(horizontalRatio * this.width);
        const y = Math.floor(verticalRatio * this.height);
        const index = (x + y * this.width) * 4;
        return this.array[index, index+1, index+2, index+3]
    }
}


class Mesh{

    constructor(triangles, lines, points, texture){
        this.triangles = triangles;
        this.lines = lines;
        this.points = points;
        this.texture = texture;
    }
    
}


// Donut texture



function DonutMesh(){
    const step_circle = 2*Math.PI/N_STEPS_CIRCLE;
    const step_donut = 2*Math.PI/N_STEPS_DONUT;
    const triangles = [];
    const points = [];
    const lines = [];
    const c_r = CIRCLE_RADIUS;
    const h_r = HOLE_RADIUS;
    const screen = new Screen(width, height);
    for (let i = 0; i < 2*Math.PI; i+=step_circle){
        for (j = 0; j < 2*Math.PI; j+=step_donut){
            let p1 = new Vector(Math.cos(i)*c_r + ( h_r + c_r), Math.sin(i)*c_r, 0)
            let n1 = new Vector(Math.cos(i), Math.sin(i), 0).normalize();
            let p2 = new Vector(Math.cos(i+step_circle)*c_r + ( h_r + c_r), Math.sin(i+step_circle)*c_r, 0)
            let n2 = new Vector(Math.cos(i+step_circle), Math.sin(i+step_circle), 0).normalize();
            let p3 = p1.copy(); let p4 = p2.copy();
            let n3 = n1.copy(); let n4 = n2.copy();
            p1 = p1.rotateY(j); p2 = p2.rotateY(j); p3 = p3.rotateY(j+step_donut); p4 = p4.rotateY(j+step_donut);
            n1 = n1.rotateY(j); n2 = n2.rotateY(j); n3 = n3.rotateY(j+step_donut); n4 = n4.rotateY(j+step_donut);
            t1 = new Triangle(p1, p2, p3); t2 = new Triangle(p3, p2, p4);
            t1.setNormalAtVertices(n1, n2, n3); t2.setNormalAtVertices(n3, n2, n4);
            points.push(p1);
            lines.push(new Line(p1, p2));
            lines.push(new Line(p2, p3));
            lines.push(new Line(p3, p1));
            triangles.push(t1);
            triangles.push(t2);
        }
    }
    return {triangles, points, lines};
}

donut = DonutMesh();

function drawDonut(rotation){
    const screen = new Screen(width, height);

    let {triangles, points, lines} = donut;
    
    triangles = triangles.map(triangle => triangle.rotate(rotation));
    points = points.map(point => point.rotate(rotation));
    lines = lines.map(line => line.rotate(rotation));

    const objects = [...triangles, ...lines];

    // Sort objects by z position of first point
    objects.sort((a,b) => {
        return  b.getZ() - a.getZ();
    });

    objects.forEach(object => {
        if (object instanceof Triangle){
            screen.triangle(object);
        } else if (object instanceof Line){
            // screen.line(object, [0, 0, 0], [0, 0, 0]);
        }
    });
    // points.forEach(point => screen.point(point, [255, 0, 0]));


    screen.draw();
}


function drawTriange(rotation){
    const size = 50;
    const screen = new Screen(size, size);
    const triangle_height = size / 3;
    p1 = new Vector(triangle_height, 0, 0);
    p2 = new Vector(-triangle_height, 0, 0);
    p3 = new Vector(0, -triangle_height, 0);

    p1 = p1.rotate(rotation);
    p2 = p2.rotate(rotation);
    p3 = p3.rotate(rotation);

    t = new Triangle(p2, p1, p3);

    screen.triangle(t);
    
    screen.line(p1, p2, [255, 0, 0], [255, 0, 0]);
    screen.line(p2, p3, [255, 0, 0], [255, 0, 0]);
    screen.line(p3, p1, [255, 0, 0], [255, 0, 0]);


    screen.point(p1, [255, 0, 0]);
    screen.point(p2, [255, 0, 0]);
    screen.point(p3, [255, 0, 0]);
    screen.draw(10);
}

function frequencyArt(rotation, timestamp){
    const screen = new Screen(width, height);
    
    // Frequency of distance from center
    frequency = 0.1;
    
}



// drawDonut(1,1,0);

const rotation = {
    x: 0,
    y: -Math.PI/2,
    z: 0,
}
// Animation
let start_time = window.performance.now()/1000;
function loop(timestamp) {
    seconds = timestamp/1000;
    fps = 1/(seconds - start_time);
    start_time = seconds;
    drawDonut(rotation);
    // drawTriange(rotation);
    rotation.x = Math.PI*seconds * 0.05;
    rotation.y = Math.PI*seconds * 0.1;

    requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);
</script>